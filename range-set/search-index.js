var searchIndex = {};
searchIndex["range_set"] = {"doc":"`RangeSet` container type","items":[[3,"RangeSet","range_set","A set of primitive integers represented as a sorted list of disjoint, inclusive ranges.",null,null],[3,"Iter","","",null,null],[5,"report_sizes","","Report some sizes of various range set types",null,{"inputs":[],"output":null}],[0,"range_compare","","Type and functions for comparing inclusive ranges",null,null],[4,"RangeCompare","range_set::range_compare","Result of comparing a pair of ranges `(A,B)`",null,null],[13,"Disjoint","","",0,null],[13,"Intersect","","",0,null],[4,"RangeDisjoint","","Ways in which a pair of ranges `(A,B)` can be disjoint",null,null],[13,"EmptyBoth","","`A = B = {}`",1,null],[13,"EmptyLhs","","`A = {}`",1,null],[13,"EmptyRhs","","`B = {}`",1,null],[13,"LessThanProper","","`[ A ] [ B ]`",1,null],[13,"LessThanAdjacent","","`[ A ][ B ]`",1,null],[13,"GreaterThanProper","","`[ B ] [ A ]`",1,null],[13,"GreaterThanAdjacent","","`[ B ][ A ]`",1,null],[4,"RangeIntersect","","Ways in which a pair of ranges `(A,B)` can intersect",null,null],[13,"EqualTo","","`[ A=B ]`",2,null],[13,"OverlapsLeft","","`[ A [ ] B ]`",2,null],[13,"OverlapsRight","","`[ B [ ] A ]`",2,null],[13,"ContainsFirst","","`[ B ] A ]`",2,null],[13,"ContainsProper","","`[ A [ B ] ]`",2,null],[13,"ContainsLast","","`[ A [ B ]`",2,null],[13,"ContainedByFirst","","`[ A ] B ]`",2,null],[13,"ContainedByProper","","`[ [ A ] B ]`",2,null],[13,"ContainedByLast","","`[ B [ A ]`",2,null],[5,"range_compare","","Compare two inclusive ranges.",null,{"inputs":[{"name":"rangeinclusive"},{"name":"rangeinclusive"}],"output":{"name":"rangecompare"}}],[5,"intersection","","Compute the intersection of two inclusive ranges. Returns an empty range if they are disjoint.",null,{"inputs":[{"name":"rangeinclusive"},{"name":"rangeinclusive"}],"output":{"name":"rangeinclusive"}}],[5,"is_empty","","TODO: replace with standard library is_empty method when PR #48087 is merged",null,{"inputs":[{"name":"rangeinclusive"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"rangecompare"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"rangecompare"}],"output":{"name":"bool"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"rangedisjoint"}],"output":{"name":"bool"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"rangeintersect"}],"output":{"name":"bool"}}],[11,"from","","",0,{"inputs":[{"name":"rangedisjoint"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"rangeintersect"}],"output":{"name":"self"}}],[11,"compare","","Tests two inclusive ranges for disjointness, returning `None` if they intersect.",1,{"inputs":[{"name":"rangeinclusive"},{"name":"rangeinclusive"}],"output":{"name":"option"}}],[11,"compare","","Test two inclusive ranges for intersection, returning `None` if the ranges are disjoint.",2,{"inputs":[{"name":"rangeinclusive"},{"name":"rangeinclusive"}],"output":{"name":"option"}}],[11,"clone","range_set","",3,{"inputs":[{"name":"self"}],"output":{"name":"rangeset"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"rangeset"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"self"},{"name":"rangeset"}],"output":{"name":"bool"}}],[11,"new","","New empty range set",3,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","New empty range set with the internal smallvec initialized with the given initial capacity",3,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"from_ranges","","Returns a new range set if the given vector of ranges is valid (`valid_range_vec`)",3,{"inputs":[{"name":"smallvec"}],"output":{"name":"option"}}],[11,"is_empty","","Check if range set is empty",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"clear","","Clears the range set",3,{"inputs":[{"name":"self"}],"output":null}],[11,"into_smallvec","","Converts into the internal smallvec",3,{"inputs":[{"name":"self"}],"output":{"name":"smallvec"}}],[11,"insert","","Insert a single element, returning true if it was successfully inserted or else false if it was already present",3,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[11,"remove","","Remove a single element, returning true if it was successfully removed or else false if it was not present",3,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[11,"insert_range","","Returns the intersected values if the range is not disjoint with the curret range set.",3,null],[11,"remove_range","","Removes and returns the intersected elements, if there were any.",3,null],[11,"iter","","",3,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"valid_range_vec","","Tests a raw smallvec of ranges for validity as a range set: the element ranges must be properly disjoint (not adjacent) and sorted.",3,{"inputs":[{"name":"smallvec"}],"output":{"name":"bool"}}],[11,"spilled","","Calls `spilled` on the underlying smallvec",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"shrink_to_fit","","Calls `shrink_to_fit` on the underlying smallvec",3,{"inputs":[{"name":"self"}],"output":null}],[11,"from","","",3,{"inputs":[{"name":"rangeinclusive"}],"output":{"name":"self"}}],[11,"next","","",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}]],"paths":[[4,"RangeCompare"],[4,"RangeDisjoint"],[4,"RangeIntersect"],[3,"RangeSet"],[3,"Iter"]]};
initSearch(searchIndex);
